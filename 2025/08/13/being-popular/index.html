

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jordan Zou">
  <meta name="keywords" content="">
  
    <meta name="description" content="Being PopularMay 2001 (This article was written as a kind of business plan for a new language. So it is missing (because it takes for granted) the most important feature of a good programming language">
<meta property="og:type" content="article">
<meta property="og:title" content="编程语言的流行之道">
<meta property="og:url" content="https://hokkaidornis.github.io/2025/08/13/being-popular/index.html">
<meta property="og:site_name" content="Hokkaidornis">
<meta property="og:description" content="Being PopularMay 2001 (This article was written as a kind of business plan for a new language. So it is missing (because it takes for granted) the most important feature of a good programming language">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-13T01:26:40.000Z">
<meta property="article:modified_time" content="2025-08-13T02:02:00.577Z">
<meta property="article:author" content="Jordan Zou">
<meta property="article:tag" content="PAUL GRAHAM">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>编程语言的流行之道 - Hokkaidornis</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"hokkaidornis.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"sGbnjJgvnzWDjQzMDVNcUPGF-gzGzoHsz","app_key":"iD8UWkcGdixFXroZ6woVTZyD","server_url":"https://sgbnjjgv.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>北海企鹅</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="编程语言的流行之道"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-13 09:26" pubdate>
          2025年8月13日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          88 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">编程语言的流行之道</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="Being-Popular"><a href="#Being-Popular" class="headerlink" title="Being Popular"></a>Being Popular</h2><p>May 2001</p>
<p>(This article was written as a kind of business plan for a new language. So it is missing (because it takes for granted) the most important feature of a good programming language: very powerful abstractions.)</p>
<p>（本文最初是作为一种新语言的 “商业计划” 撰写的。因此，它忽略了（或想当然地认为）优秀编程语言最重要的特性：强大的抽象能力。）</p>
<p>A friend of mine once told an eminent operating systems expert that he wanted to design a really good programming language. The expert told him that it would be a waste of time, that programming languages don’t become popular or unpopular based on their merits, and so no matter how good his language was, no one would use it. At least, that was what had happened to the language he had designed.</p>
<p>我有个朋友曾跟一位著名的操作系统专家说，他想设计一种真正优秀的编程语言。专家告诉他这是浪费时间 —— 编程语言的流行与否并不取决于其本身的优劣，所以无论他的语言多好，都不会有人用。至少，专家自己设计的语言就遭遇了这种命运。</p>
<p>What does make a language popular? Do popular languages deserve their popularity? Is it worth trying to define a good programming language? How would you do it?</p>
<p>那么，究竟是什么让一种语言流行起来？流行的语言真的配得上它们的热度吗？费心设计一种好语言值得吗？又该如何设计呢？</p>
<p>I think the answers to these questions can be found by looking at hackers, and learning what they want. Programming languages are for hackers, and a programming language is good as a programming language (rather than, say, an exercise in denotational semantics or compiler design) if and only if hackers like it.</p>
<p>我认为，答案可以从 “黑客”（优秀程序员）身上找到 —— 关键是弄清楚他们想要什么。编程语言是为黑客服务的，一种编程语言之所以优秀（而非仅仅是符号语义或编译器设计的练习），<strong>当且仅当黑客喜欢它</strong>。</p>
<h3 id="1-The-Mechanics-of-Popularity"><a href="#1-The-Mechanics-of-Popularity" class="headerlink" title="1 The Mechanics of Popularity"></a><strong>1 The Mechanics of Popularity</strong></h3><p><strong>1 流行的机制</strong></p>
<p>It’s true, certainly, that most people don’t choose programming languages simply based on their merits. Most programmers are told what language to use by someone else. And yet I think the effect of such external factors on the popularity of programming languages is not as great as it’s sometimes thought to be. I think a bigger problem is that a hacker’s idea of a good programming language is not the same as most language designers’.</p>
<p>诚然，大多数人选择编程语言并非单纯看其本身的优点。多数程序员是听别人的指令选择语言的。但我认为，这种外部因素对编程语言流行度的影响，并没有人们想象中那么大。更大的问题在于：黑客对 “好语言” 的定义，与多数语言设计者的理解根本不同。</p>
<p>Between the two, the hacker’s opinion is the one that matters. Programming languages are not theorems. They’re tools, designed for people, and they have to be designed to suit human strengths and weaknesses as much as shoes have to be designed for human feet. If a shoe pinches when you put it on, it’s a bad shoe, however elegant it may be as a piece of sculpture.</p>
<p>两者中，黑客的观点才是关键。编程语言不是定理，而是为人设计的工具 —— 它们必须适配人类的优缺点，就像鞋子必须适配人类的脚一样。如果一只鞋穿上就夹脚，哪怕它作为雕塑再精致，也是一只烂鞋</p>
<p>It may be that the majority of programmers can’t tell a good language from a bad one. But that’s no different with any other tool. It doesn’t mean that it’s a waste of time to try designing a good language. Expert hackers can tell a good language when they see one, and they’ll use it. Expert hackers are a tiny minority, admittedly, but that tiny minority write all the good software, and their influence is such that the rest of the programmers will tend to use whatever language they use. Often, indeed, it is not merely influence but command: often the expert hackers are the very people who, as their bosses or faculty advisors, tell the other programmers what language to use.</p>
<p>或许多数程序员分不清语言的好坏，但这在任何工具上都一样。这并不意味着设计好语言是浪费时间。顶尖黑客一眼就能识别好语言，而且会主动使用它。诚然，顶尖黑客只是极少数，但正是这极少数人写出了所有优秀软件，他们的影响力足以让其他程序员跟风使用他们选择的语言。事实上，这往往不止是影响力，更是 “命令”：顶尖黑客常常是老板或导师，直接告诉其他程序员该用什么语言。</p>
<p>The opinion of expert hackers is not the only force that determines the relative popularity of programming languages — legacy software (Cobol) and hype (Ada, Java) also play a role — but I think it is the most powerful force over the long term. Given an initial critical mass and enough time, a programming language probably becomes about as popular as it deserves to be. And popularity further separates good languages from bad ones, because feedback from real live users always leads to improvements. Look at how much any popular language has changed during its life. Perl and Fortran are extreme cases, but even Lisp has changed a lot. Lisp 1.5 didn’t have macros, for example; these evolved later, after hackers at MIT had spent a couple years using Lisp to write real programs. [1]</p>
<p>顶尖黑客的看法并非决定编程语言流行度的唯一因素 —— 遗留软件（如 Cobol）和炒作（如 Ada、Java）也有影响 —— 但长期来看，它是最强大的力量。只要有初始的 “临界规模” 和足够的时间，一种编程语言的流行度大致会与其 “应得的” 相匹配。而流行度会进一步拉开好语言与坏语言的差距：真实用户的反馈总能推动语言改进。看看任何流行语言在其生命周期中的变化就知道了。Perl 和 Fortran 是极端例子，但即便是 Lisp 也变了很多 —— 比如 Lisp 1.5 原本没有宏，是麻省理工的黑客用它写了几年实际程序后，才逐步演化出来的。[1]</p>
<p>So whether or not a language has to be good to be popular, I think a language has to be popular to be good. And it has to stay popular to stay good. The state of the art in programming languages doesn’t stand still. And yet the Lisps we have today are still pretty much what they had at MIT in the mid-1980s, because that’s the last time Lisp had a sufficiently large and demanding user base.</p>
<p>所以，无论 “优秀” 是不是 “流行” 的前提，我认为 “流行” 是 “优秀” 的前提 —— 而且语言必须保持流行才能保持优秀。编程语言的技术水平不会停滞不前。但如今的 Lisp 几乎还停留在 20 世纪 80 年代中期麻省理工的水平，因为那是 Lisp 最后一次拥有足够庞大且高要求的用户群体。</p>
<p>Of course, hackers have to know about a language before they can use it. How are they to hear? From other hackers. But there has to be some initial group of hackers using the language for others even to hear about it. I wonder how large this group has to be; how many users make a critical mass? Off the top of my head, I’d say twenty. If a language had twenty separate users, meaning twenty users who decided on their own to use it, I’d consider it to be real.</p>
<p>当然，黑客得先知道一种语言，才可能用它。他们怎么知道呢？从其他黑客那里。但必须有一群初始用户先用起来，别人才可能听说它。我好奇这个 “临界规模” 需要多大 —— 多少用户才算足够？凭直觉说，20 个吧。如果一种语言有 20 个独立用户（即 20 个主动选择使用它的人），我就认为它 “站稳脚跟” 了。</p>
<p>Getting there can’t be easy. I would not be surprised if it is harder to get from zero to twenty than from twenty to a thousand. The best way to get those initial twenty users is probably to use a trojan horse: to give people an application they want, which happens to be written in the new language.</p>
<p>达到这个数字并不容易。从 0 到 20，可能比从 20 到 1000 更难。获取初始 20 个用户的最佳方式或许是 “特洛伊木马” 策略：给人们一个他们想要的应用，而这个应用恰好是用新语言写的。</p>
<h3 id="2-External-Factors"><a href="#2-External-Factors" class="headerlink" title="2 External Factors"></a><strong>2 External Factors</strong></h3><p><strong>2 外部因素</strong></p>
<p>Let’s start by acknowledging one external factor that does affect the popularity of a programming language. To become popular, a programming language has to be the scripting language of a popular system. Fortran and Cobol were the scripting languages of early IBM mainframes. C was the scripting language of Unix, and so, later, was Perl. Tcl is the scripting language of Tk. Java and Javascript are intended to be the scripting languages of web browsers.]</p>
<p>首先要承认，有一个外部因素确实影响编程语言的流行度：要流行，它必须是某个流行系统的 “脚本语言”。Fortran 和 Cobol 是早期 IBM 大型机的脚本语言；C（后来还有 Perl）是 Unix 的脚本语言；Tcl 是 Tk 的脚本语言；Java 和 Javascript 则是为网页浏览器设计的脚本语言。</p>
<p>Lisp is not a massively popular language because it is not the scripting language of a massively popular system. What popularity it retains dates back to the 1960s and 1970s, when it was the scripting language of MIT. A lot of the great programmers of the day were associated with MIT at some point. And in the early 1970s, before C, MIT’s dialect of Lisp, called MacLisp, was one of the only programming languages a serious hacker would want to use.</p>
<p>Lisp 之所以不火，就是因为它不是某个主流系统的脚本语言。它仅存的热度可以追溯到 20 世纪 60-70 年代 —— 当时它是麻省理工的 “脚本语言”。那个年代许多顶尖程序员都与麻省理工有关联，而在 20 世纪 70 年代初 C 语言出现之前，麻省理工的 Lisp 方言（MacLisp）是顶尖黑客唯一愿意用的语言之一。</p>
<p>Today Lisp is the scripting language of two moderately popular systems, Emacs and Autocad, and for that reason I suspect that most of the Lisp programming done today is done in Emacs Lisp or AutoLisp.</p>
<p>如今，Lisp 是两个中等流行系统（Emacs 和 Autocad）的脚本语言，因此我猜测，现在多数 Lisp 编程都是用 Emacs Lisp 或 AutoLisp 完成的。</p>
<p>Programming languages don’t exist in isolation. To hack is a transitive verb — hackers are usually hacking something — and in practice languages are judged relative to whatever they’re used to hack. So if you want to design a popular language, you either have to supply more than a language, or you have to design your language to replace the scripting language of some existing system.</p>
<p>编程语言并非孤立存在。“编程” 是个及物动词 —— 黑客通常在 “编” 某个东西 —— 而实际上，语言的评价总是与其所编写的对象相关。所以，若想设计一种流行语言，要么你得提供的不只是语言本身，要么就得让它能替代某个现有系统的脚本语言。</p>
<p>Common Lisp is unpopular partly because it’s an orphan. It did originally come with a system to hack: the Lisp Machine. But Lisp Machines (along with parallel computers) were steamrollered by the increasing power of general purpose processors in the 1980s. Common Lisp might have remained popular if it had been a good scripting language for Unix. It is, alas, an atrociously bad one.</p>
<p>Common Lisp 之所以冷门，部分原因是它 “无家可归”。它最初确实有对应的系统：Lisp 机器。但 20 世纪 80 年代，随着通用处理器性能飙升，Lisp 机器（和并行计算机）被碾压了。如果 Common Lisp 能成为 Unix 的优秀脚本语言，或许还能保持流行 —— 可惜，它在这方面烂得离谱。</p>
<p>One way to describe this situation is to say that a language isn’t judged on its own merits. Another view is that a programming language really isn’t a programming language unless it’s also the scripting language of something. This only seems unfair if it comes as a surprise. I think it’s no more unfair than expecting a programming language to have, say, an implementation. It’s just part of what a programming language is.</p>
<p>这种情况可以理解为：语言的评价并非基于自身优点。但换个角度看，一种编程语言若不能成为某个系统的脚本语言，或许就不算真正的编程语言。这听起来不公平，但若接受它，就会发现这并不比 “编程语言需要实现” 更苛刻 —— 这只是编程语言的固有属性之一。</p>
<p>A programming language does need a good implementation, of course, and this must be free. Companies will pay for software, but individual hackers won’t, and it’s the hackers you need to attract.</p>
<p>当然，编程语言需要优秀的实现，而且必须免费。公司会为软件付费，但个体黑客不会 —— 而你需要吸引的正是黑客。</p>
<p>A language also needs to have a book about it. The book should be thin, well-written, and full of good examples. K&amp;R is the ideal here. At the moment I’d almost say that a language has to have a book published by O’Reilly. That’s becoming the test of mattering to hackers.</p>
<p>语言还需要一本相关的书。这本书得薄、写得好、充满好例子。《C 程序设计语言》（K&amp;R）就是典范。如今我甚至想说，一种语言必须有 O’Reilly 出版的书 —— 这几乎成了 “被黑客认可” 的试金石。</p>
<p>There should be online documentation as well. In fact, the book can start as online documentation. But I don’t think that physical books are outmoded yet. Their format is convenient, and the de facto censorship imposed by publishers is a useful if imperfect filter. Bookstores are one of the most important places for learning about new languages.</p>
<p>在线文档也得有。事实上，书籍最初可以是在线文档，但实体书还没过时：它们的格式方便，出版商的 “隐性审查” 虽然不完美，却是个有用的筛选机制。书店是了解新语言的重要场所之一。</p>
<h3 id="3-Brevity"><a href="#3-Brevity" class="headerlink" title="3 Brevity"></a><strong>3 Brevity</strong></h3><p><strong>3 简洁性</strong></p>
<p>Given that you can supply the three things any language needs — a free implementation, a book, and something to hack — how do you make a language that hackers will like?</p>
<p>假设你已经提供了语言所需的三样东西 —— 免费实现、书籍、可编写的对象 —— 那么如何让黑客喜欢它？</p>
<p>One thing hackers like is brevity. Hackers are lazy, in the same way that mathematicians and modernist architects are lazy: they hate anything extraneous. It would not be far from the truth to say that a hacker about to write a program decides what language to use, at least subconsciously, based on the total number of characters he’ll have to type. If this isn’t precisely how hackers think, a language designer would do well to act as if it were.</p>
<p>黑客喜欢的一点是<strong>简洁</strong>。黑客的 “懒”，就像数学家和现代主义建筑师的 “懒”：他们讨厌任何多余的东西。说 “黑客选择语言时（至少潜意识里）会算自己要敲多少个字符”，也不算太夸张。就算黑客不是真这么想，语言设计者按这个逻辑做也没错。</p>
<p>It is a mistake to try to baby the user with long-winded expressions that are meant to resemble English. Cobol is notorious for this flaw. A hacker would consider being asked to write</p>
<p>add x to y giving z</p>
<p>instead of</p>
<p>z &#x3D; x+y</p>
<p>as something between an insult to his intelligence and a sin against God.</p>
<p>试图用冗长的、类似英语的表达 “迁就” 用户，是个错误。Cobol 就因这个缺陷臭名昭著。黑客会觉得，让他们写<code>add x to y giving z</code>而非<code>z = x+y</code>，简直是对智商的侮辱，甚至是对上帝的亵渎。</p>
<p>It has sometimes been said that Lisp should use first and rest instead of car and cdr, because it would make programs easier to read. Maybe for the first couple hours. But a hacker can learn quickly enough that car means the first element of a list and cdr means the rest. Using first and rest means 50% more typing. And they are also different lengths, meaning that the arguments won’t line up when they’re called, as car and cdr often are, in successive lines. I’ve found that it matters a lot how code lines up on the page. I can barely read Lisp code when it is set in a variable-width font, and friends say this is true for other languages too.</p>
<p>有人说 Lisp 应该用<code>first</code>和<code>rest</code>替代<code>car</code>和<code>cdr</code>，这样程序更易读。或许前几个小时是这样，但黑客很快就会记住<code>car</code>指列表的第一个元素、<code>cdr</code>指剩余部分。用<code>first</code>和<code>rest</code>意味着多敲 50% 的字符，而且两者长度不同 —— 当它们在连续行中出现时，参数都对不齐。我发现代码在页面上的排版非常重要：用变宽字体显示的 Lisp 代码，我几乎读不下去，朋友说其他语言也是如此。</p>
<p>Brevity is one place where strongly typed languages lose. All other things being equal, no one wants to begin a program with a bunch of declarations. Anything that can be implicit, should be.</p>
<p>强类型语言在简洁性上吃亏。其他条件相同时，没人想在程序开头写一堆声明。任何能隐含的信息，都该隐含。</p>
<p>The individual tokens should be short as well. Perl and Common Lisp occupy opposite poles on this question. Perl programs can be almost cryptically dense, while the names of built-in Common Lisp operators are comically long. The designers of Common Lisp probably expected users to have text editors that would type these long names for them. But the cost of a long name is not just the cost of typing it. There is also the cost of reading it, and the cost of the space it takes up on your screen.</p>
<p>单个符号也该短。Perl 和 Common Lisp 在这方面是两个极端：Perl 程序密得像密码，而 Common Lisp 的内置操作符名字长得可笑。Common Lisp 的设计者可能以为用户会用文本编辑器自动输入这些长名字，但长名字的成本不止是输入 —— 还有阅读成本和屏幕空间占用成本。</p>
<h3 id="4-Hackability"><a href="#4-Hackability" class="headerlink" title="4 Hackability"></a><strong>4 Hackability</strong></h3><p><strong>4 可操作性</strong></p>
<p>There is one thing more important than brevity to a hacker: being able to do what you want. In the history of programming languages a surprising amount of effort has gone into preventing programmers from doing things considered to be improper. This is a dangerously presumptuous plan. How can the language designer know what the programmer is going to need to do? I think language designers would do better to consider their target user to be a genius who will need to do things they never anticipated, rather than a bumbler who needs to be protected from himself. The bumbler will shoot himself in the foot anyway. You may save him from referring to variables in another package, but you can’t save him from writing a badly designed program to solve the wrong problem, and taking forever to do it.</p>
<p>对黑客来说，有一样东西比简洁更重要：<strong>能做自己想做的事</strong>。编程语言史上，太多精力浪费在 “阻止程序员做被认为不恰当的事” 上。这是个危险的自负计划 —— 语言设计者怎么可能知道程序员需要做什么？我认为，设计者更该假设目标用户是 “需要做你从未预料之事的天才”，而非 “需要被保护的笨蛋”。笨蛋总会搬起石头砸自己的脚：你或许能阻止他引用其他包的变量，却阻止不了他用糟糕的设计解决错误的问题，还浪费大量时间。</p>
<p>Good programmers often want to do dangerous and unsavory things. By unsavory I mean things that go behind whatever semantic facade the language is trying to present: getting hold of the internal representation of some high-level abstraction, for example. Hackers like to hack, and hacking means getting inside things and second guessing the original designer.</p>
<p>优秀程序员常常想做 “危险” 或 “不体面” 的事。“不体面” 指绕过语言试图呈现的语义伪装 —— 比如获取某个高层抽象的内部表示。黑客就喜欢 “折腾”，而折腾意味着深入内部、质疑最初的设计。</p>
<p>Let yourself be second guessed. When you make any tool, people use it in ways you didn’t intend, and this is especially true of a highly articulated tool like a programming language. Many a hacker will want to tweak your semantic model in a way that you never imagined. I say, let them; give the programmer access to as much internal stuff as you can without endangering runtime systems like the garbage collector.</p>
<p>允许他们质疑你。任何工具都会被用在设计者未预料的地方，编程语言这种高度灵活的工具更是如此。许多黑客会想以你从未想过的方式调整你的语义模型 —— 我说，让他们做吧。在不危及垃圾回收等运行时系统的前提下，尽可能让程序员接触内部机制。</p>
<p>In Common Lisp I have often wanted to iterate through the fields of a struct — to comb out references to a deleted object, for example, or find fields that are uninitialized. I know the structs are just vectors underneath. And yet I can’t write a general purpose function that I can call on any struct. I can only access the fields by name, because that’s what a struct is supposed to mean.</p>
<p>在 Common Lisp 中，我常想遍历结构体的字段 —— 比如梳理已删除对象的引用，或查找未初始化的字段。我知道结构体本质上是向量，但就是写不出一个能作用于任何结构体的通用函数。我只能通过字段名访问，因为 “结构体就该是这样”。</p>
<p>A hacker may only want to subvert the intended model of things once or twice in a big program. But what a difference it makes to be able to. And it may be more than a question of just solving a problem. There is a kind of pleasure here too. Hackers share the surgeon’s secret pleasure in poking about in gross innards, the teenager’s secret pleasure in popping zits. [2] For boys, at least, certain kinds of horrors are fascinating. Maxim magazine publishes an annual volume of photographs, containing a mix of pin-ups and grisly accidents. They know their audience.</p>
<p>黑客可能在一个大程序中只需要颠覆一次语义模型，但 “能做到” 的意义重大。这甚至不止是解决问题 —— 其中还有一种乐趣。黑客和外科医生一样，喜欢在 “ gross innards” 里摸索；和青少年一样，喜欢挤痘痘。[2] 至少对男性来说，某些 “恶心” 的东西很有吸引力。《Maxim》杂志每年会出一本照片集，混合了美女和恐怖事故 —— 他们太懂受众了。</p>
<p>Historically, Lisp has been good at letting hackers have their way. The political correctness of Common Lisp is an aberration. Early Lisps let you get your hands on everything. A good deal of that spirit is, fortunately, preserved in macros. What a wonderful thing, to be able to make arbitrary transformations on the source code.</p>
<p>历史上，Lisp 很擅长让黑客为所欲为。Common Lisp 的 “政治正确” 是个例外。早期 Lisp 让你能接触一切，幸运的是，这种精神在宏中保留了不少。能对源代码做任意转换，多美妙啊。</p>
<p>Classic macros are a real hacker’s tool — simple, powerful, and dangerous. It’s so easy to understand what they do: you call a function on the macro’s arguments, and whatever it returns gets inserted in place of the macro call. Hygienic macros embody the opposite principle. They try to protect you from understanding what they’re doing. I have never heard hygienic macros explained in one sentence. And they are a classic example of the dangers of deciding what programmers are allowed to want. Hygienic macros are intended to protect me from variable capture, among other things, but variable capture is exactly what I want in some macros.</p>
<p>经典宏是黑客的真正工具 —— 简单、强大、危险。其原理一目了然：用函数处理宏的参数，返回值直接替换宏调用。而 “卫生宏” 则相反，它们试图阻止你理解其原理。我从没听过有人能用一句话解释卫生宏。它们是 “替程序员决定需求” 的典型反面教材：卫生宏想保护我免受变量捕获的影响，但有时我就需要变量捕获。</p>
<p>A really good language should be both clean and dirty: cleanly designed, with a small core of well understood and highly orthogonal operators, but dirty in the sense that it lets hackers have their way with it. C is like this. So were the early Lisps. A real hacker’s language will always have a slightly raffish character.</p>
<p>真正的好语言应该既 “干净” 又 “肮脏”：设计干净，核心是少量易懂且高度正交的操作符；但 “肮脏” 在于允许黑客折腾。C 是这样，早期 Lisp 也是这样。真正的黑客语言总会带点 “痞气”。</p>
<p>A good programming language should have features that make the kind of people who use the phrase “software engineering” shake their heads disapprovingly. At the other end of the continuum are languages like Ada and Pascal, models of propriety that are good for teaching and not much else.</p>
<p>优秀编程语言的特性，应该能让那些张口闭口 “软件工程” 的人摇头反对。而另一端是 Ada、Pascal 这类 “得体” 的语言 —— 适合教学，仅此而已。</p>
<h3 id="5-Throwaway-Programs"><a href="#5-Throwaway-Programs" class="headerlink" title="5 Throwaway Programs"></a><strong>5 Throwaway Programs</strong></h3><p><strong>5 一次性程序</strong></p>
<p>To be attractive to hackers, a language must be good for writing the kinds of programs they want to write. And that means, perhaps surprisingly, that it has to be good for writing throwaway programs.</p>
<p>要吸引黑客，语言必须擅长写他们想写的程序 —— 而这意味着，它得擅长写 “一次性程序”，这可能有点出人意料。</p>
<p>A throwaway program is a program you write quickly for some limited task: a program to automate some system administration task, or generate test data for a simulation, or convert data from one format to another. The surprising thing about throwaway programs is that, like the “temporary” buildings built at so many American universities during World War II, they often don’t get thrown away. Many evolve into real programs, with real features and real users.</p>
<p>一次性程序是为特定任务快速写的程序：比如自动化系统管理、生成模拟测试数据、转换数据格式等。有趣的是，就像二战期间美国大学的 “临时” 建筑，许多一次性程序最后并没有被扔掉，而是演变成有实际功能和用户的正式程序。</p>
<p>I have a hunch that the best big programs begin life this way, rather than being designed big from the start, like the Hoover Dam. It’s terrifying to build something big from scratch. When people take on a project that’s too big, they become overwhelmed. The project either gets bogged down, or the result is sterile and wooden: a shopping mall rather than a real downtown, Brasilia rather than Rome, Ada rather than C.</p>
<p>我有种直觉：优秀的大型程序往往是这样诞生的，而非像胡佛水坝那样从一开始就按 “大型” 设计。从零开始做大型项目太可怕了，人们会被压垮 —— 要么停滞不前，要么做出僵化刻板的结果：像购物中心而非真正的市中心，像巴西利亚而非罗马，像 Ada 而非 C。</p>
<p>Another way to get a big program is to start with a throwaway program and keep improving it. This approach is less daunting, and the design of the program benefits from evolution. I think, if one looked, that this would turn out to be the way most big programs were developed. And those that did evolve this way are probably still written in whatever language they were first written in, because it’s rare for a program to be ported, except for political reasons. And so, paradoxically, if you want to make a language that is used for big systems, you have to make it good for writing throwaway programs, because that’s where big systems come from.</p>
<p>另一种做出大型程序的方式是：从一次性程序开始，不断改进。这种方式没那么吓人，程序设计也能从演化中受益。我猜，多数大型程序都是这么来的。而且，除非出于政治原因，这些程序通常会一直用最初的语言编写。所以矛盾的是，若想让语言被用于大型系统，就得让它擅长写一次性程序 —— 因为大型系统就从这里来。</p>
<p>Perl is a striking example of this idea. It was not only designed for writing throwaway programs, but was pretty much a throwaway program itself. Perl began life as a collection of utilities for generating reports, and only evolved into a programming language as the throwaway programs people wrote in it grew larger. It was not until Perl 5 (if then) that the language was suitable for writing serious programs, and yet it was already massively popular.</p>
<p>Perl 就是个鲜明例子。它不仅是为一次性程序设计的，甚至本身就像个一次性程序。Perl 最初是一堆生成报告的工具，后来随着人们用它写的一次性程序变大，才演变成编程语言。直到 Perl 5（甚至更晚），它才适合写严肃程序，但那时它已经很火了。</p>
<p>What makes a language good for throwaway programs? To start with, it must be readily available. A throwaway program is something that you expect to write in an hour. So the language probably must already be installed on the computer you’re using. It can’t be something you have to install before you use it. It has to be there. C was there because it came with the operating system. Perl was there because it was originally a tool for system administrators, and yours had already installed it.</p>
<p>什么让语言适合写一次性程序？首先，它必须 “触手可及”。一次性程序通常期望一小时内写完，所以它得预装在你用的电脑上 —— 不能是那种需要先安装才能用的。C 能普及，因为它随操作系统预装；Perl 能普及，因为它最初是系统管理员的工具，管理员已经装好了。</p>
<p>Being available means more than being installed, though. An interactive language, with a command-line interface, is more available than one that you have to compile and run separately. A popular programming language should be interactive, and start up fast.</p>
<p>“触手可及” 不止是预装。带命令行界面的交互式语言，比需要单独编译运行的语言更方便。流行的编程语言应该是交互式的，且启动快。</p>
<p>Another thing you want in a throwaway program is brevity. Brevity is always attractive to hackers, and never more so than in a program they expect to turn out in an hour.</p>
<p>一次性程序还需要简洁。简洁对黑客总是有吸引力，在一小时就要写完的程序中更是如此。</p>
<h3 id="6-Libraries"><a href="#6-Libraries" class="headerlink" title="6 Libraries"></a><strong>6 Libraries</strong></h3><p><strong>6 库</strong></p>
<p>Of course the ultimate in brevity is to have the program already written for you, and merely to call it. And this brings us to what I think will be an increasingly important feature of programming languages: library functions. Perl wins because it has large libraries for manipulating strings. This class of library functions are especially important for throwaway programs, which are often originally written for converting or extracting data. Many Perl programs probably begin as just a couple library calls stuck together.</p>
<p>当然，最极致的简洁是 “程序已经写好了，你只需调用”—— 这就涉及到我认为未来编程语言越来越重要的特性：<strong>库函数</strong>。Perl 之所以成功，是因为它有强大的字符串处理库。这类库对一次性程序尤其重要，因为它们常用来转换或提取数据。许多 Perl 程序可能一开始就是几个库调用拼起来的。</p>
<p>I think a lot of the advances that happen in programming languages in the next fifty years will have to do with library functions. I think future programming languages will have libraries that are as carefully designed as the core language. Programming language design will not be about whether to make your language strongly or weakly typed, or object oriented, or functional, or whatever, but about how to design great libraries. The kind of language designers who like to think about how to design type systems may shudder at this. It’s almost like writing applications! Too bad. Languages are for programmers, and libraries are what programmers need.</p>
<p>我觉得未来 50 年，编程语言的进步会更多体现在库函数上。未来的编程语言，其库会和核心语言一样精心设计。语言设计不再是纠结 “强类型还是弱类型”“面向对象还是函数式”，而是如何设计优秀的库。那些喜欢琢磨类型系统的设计者可能会对此不屑 —— 这简直像在写应用！但没办法：语言是给程序员用的，而程序员需要的是库。</p>
<p>It’s hard to design good libraries. It’s not simply a matter of writing a lot of code. Once the libraries get too big, it can sometimes take longer to find the function you need than to write the code yourself. Libraries need to be designed using a small set of orthogonal operators, just like the core language. It ought to be possible for the programmer to guess what library call will do what he needs.</p>
<p>设计好库很难，不只是堆代码。库太大的话，找函数的时间可能比自己写还长。库需要像核心语言一样，用少量正交的操作符设计 —— 程序员应该能猜到哪个库调用能解决自己的问题。</p>
<p>Libraries are one place Common Lisp falls short. There are only rudimentary libraries for manipulating strings, and almost none for talking to the operating system. For historical reasons, Common Lisp tries to pretend that the OS doesn’t exist. And because you can’t talk to the OS, you’re unlikely to be able to write a serious program using only the built-in operators in Common Lisp. You have to use some implementation-specific hacks as well, and in practice these tend not to give you everything you want. Hackers would think a lot more highly of Lisp if Common Lisp had powerful string libraries and good OS support.</p>
<p>Common Lisp 的短板就在库。它的字符串处理库很初级，与操作系统交互的库几乎没有。出于历史原因，Common Lisp 试图假装操作系统不存在。而因为无法与操作系统交互，仅用 Common Lisp 的内置操作符几乎写不出严肃程序，还得用特定实现的 hacks，且往往满足不了需求。如果 Common Lisp 有强大的字符串库和良好的系统支持，黑客对它的评价会高得多。</p>
<h3 id="7-Syntax"><a href="#7-Syntax" class="headerlink" title="7 Syntax"></a><strong>7 Syntax</strong></h3><p><strong>7 语法</strong></p>
<p>Could a language with Lisp’s syntax, or more precisely, lack of syntax, ever become popular? I don’t know the answer to this question. I do think that syntax is not the main reason Lisp isn’t currently popular. Common Lisp has worse problems than unfamiliar syntax. I know several programmers who are comfortable with prefix syntax and yet use Perl by default, because it has powerful string libraries and can talk to the os.</p>
<p>Lisp 这种 “没有语法”（或说缺乏语法）的语言，有可能流行吗？我不知道答案，但我认为语法不是 Lisp 现在冷门的主因。Common Lisp 的问题比 “语法陌生” 更严重。我认识几个习惯前缀语法的程序员，却默认用 Perl—— 因为 Perl 有强大的字符串库，还能与系统交互。</p>
<p>There are two possible problems with prefix notation: that it is unfamiliar to programmers, and that it is not dense enough. The conventional wisdom in the Lisp world is that the first problem is the real one. I’m not so sure. Yes, prefix notation makes ordinary programmers panic. But I don’t think ordinary programmers’ opinions matter. Languages become popular or unpopular based on what expert hackers think of them, and I think expert hackers might be able to deal with prefix notation. Perl syntax can be pretty incomprehensible, but that has not stood in the way of Perl’s popularity. If anything it may have helped foster a Perl cult.</p>
<p>前缀表示法可能有两个问题：对程序员来说陌生，以及不够紧凑。Lisp 界的共识是 “陌生” 是主因，但我不确定。没错，前缀表示法会让普通程序员恐慌，但普通程序员的看法不重要。语言的流行取决于顶尖黑客的看法，而他们应该能接受前缀表示法。Perl 的语法够晦涩了，却没阻碍它流行 —— 甚至可能助长了 Perl 文化。</p>
<p>A more serious problem is the diffuseness of prefix notation. For expert hackers, that really is a problem. No one wants to write (aref a x y) when they could write a[x,y].</p>
<p>更严重的问题是前缀表示法的 “松散”。对顶尖黑客来说，这确实是问题：没人想写<code>(aref a x y)</code>，如果可以写成<code>a[x,y]</code>的话。</p>
<p>In this particular case there is a way to finesse our way out of the problem. If we treat data structures as if they were functions on indexes, we could write (a x y) instead, which is even shorter than the Perl form. Similar tricks may shorten other types of expressions.</p>
<p>这个问题有个解决办法：把数据结构当作 “接受索引的函数”，这样就能写成<code>(a x y)</code>，甚至比 Perl 的形式还短。类似的技巧或许能缩短其他表达式。</p>
<p>We can get rid of (or make optional) a lot of parentheses by making indentation significant. That’s how programmers read code anyway: when indentation says one thing and delimiters say another, we go by the indentation. Treating indentation as significant would eliminate this common source of bugs as well as making programs shorter.</p>
<p>我们可以通过 “缩进有意义” 来减少（或可选）大量括号。程序员读代码时本就靠缩进：当缩进和分隔符冲突时，我们信缩进。让缩进有意义，既能消除常见的 bug，又能缩短程序。</p>
<p>Sometimes infix syntax is easier to read. This is especially true for math expressions. I’ve used Lisp my whole programming life and I still don’t find prefix math expressions natural. And yet it is convenient, especially when you’re generating code, to have operators that take any number of arguments. So if we do have infix syntax, it should probably be implemented as some kind of read-macro.</p>
<p>有时中缀语法更易读，尤其是数学表达式。我用了一辈子 Lisp，还是觉得前缀数学表达式不自然。但允许操作符接受任意数量的参数（尤其在生成代码时）很方便。所以，如果要有中缀语法，或许可以用读宏实现。</p>
<p>I don’t think we should be religiously opposed to introducing syntax into Lisp, as long as it translates in a well-understood way into underlying s-expressions. There is already a good deal of syntax in Lisp. It’s not necessarily bad to introduce more, as long as no one is forced to use it. In Common Lisp, some delimiters are reserved for the language, suggesting that at least some of the designers intended to have more syntax in the future.</p>
<p>我不认为应该坚决反对给 Lisp 加语法 —— 只要语法能以清晰的方式转换为底层的 s 表达式。Lisp 已有不少语法，只要不强迫使用，多加些也无妨。Common Lisp 中有些分隔符是语言保留的，说明至少有部分设计者希望未来能加入更多语法。</p>
<p>One of the most egregiously unlispy pieces of syntax in Common Lisp occurs in format strings; format is a language in its own right, and that language is not Lisp. If there were a plan for introducing more syntax into Lisp, format specifiers might be able to be included in it. It would be a good thing if macros could generate format specifiers the way they generate any other kind of code.</p>
<p>Common Lisp 中最不 “Lisp” 的语法是格式字符串：<code>format</code>本身就是一种语言，而且不是 Lisp。如果有计划给 Lisp 加语法，格式说明符或许能包含进去 —— 这样宏就能像生成其他代码一样生成格式说明符，会是好事。</p>
<p>An eminent Lisp hacker told me that his copy of CLTL falls open to the section format. Mine too. This probably indicates room for improvement. It may also mean that programs do a lot of I&#x2F;O.</p>
<p>一位著名的 Lisp 黑客告诉我，他的《Common Lisp the Language》总是自动翻开到<code>format</code>那一节。我的也是。这可能说明有改进空间，也可能说明程序确实要做很多 I&#x2F;O。</p>
<h3 id="8-Efficiency"><a href="#8-Efficiency" class="headerlink" title="8 Efficiency"></a><strong>8 Efficiency</strong></h3><p><strong>8 效率</strong></p>
<p>A good language, as everyone knows, should generate fast code. But in practice I don’t think fast code comes primarily from things you do in the design of the language. As Knuth pointed out long ago, speed only matters in certain critical bottlenecks. And as many programmers have observed since, one is very often mistaken about where these bottlenecks are.</p>
<p>众所周知，好语言应该生成高效代码。但实际上，我认为高效代码并非主要来自语言设计 —— 正如 Knuth 早就指出的，速度只在某些关键瓶颈处重要，而程序员常常猜错瓶颈在哪。</p>
<p>So, in practice, the way to get fast code is to have a very good profiler, rather than by, say, making the language strongly typed. You don’t need to know the type of every argument in every call in the program. You do need to be able to declare the types of arguments in the bottlenecks. And even more, you need to be able to find out where the bottlenecks are.</p>
<p>所以，实际上，要得到高效代码，靠的是优秀的性能分析器，而非强类型之类的设计。你不需要知道程序中每个调用的每个参数的类型，但需要能在瓶颈处声明参数类型 —— 更重要的是，需要能找到瓶颈在哪。</p>
<p>One complaint people have had with Lisp is that it’s hard to tell what’s expensive. This might be true. It might also be inevitable, if you want to have a very abstract language. And in any case I think good profiling would go a long way toward fixing the problem: you’d soon learn what was expensive.</p>
<p>人们对 Lisp 的一个抱怨是 “说不清什么操作费时间”。这可能是真的，也可能是 “高度抽象语言” 的必然。但优秀的性能分析器应该能解决这个问题：你很快就会知道什么操作耗时。</p>
<p>Part of the problem here is social. Language designers like to write fast compilers. That’s how they measure their skill. They think of the profiler as an add-on, at best. But in practice a good profiler may do more to improve the speed of actual programs written in the language than a compiler that generates fast code. Here, again, language designers are somewhat out of touch with their users. They do a really good job of solving slightly the wrong problem.</p>
<p>这里有个社会因素：语言设计者喜欢写快速编译器 —— 这是他们衡量技能的方式。他们最多把性能分析器当作附加工具，但实际上，优秀的性能分析器对提升实际程序速度的作用，可能比生成高效代码的编译器还大。这又是语言设计者与用户脱节的地方：他们擅长解决的，是稍微跑偏的问题。</p>
<p>It might be a good idea to have an active profiler — to push performance data to the programmer instead of waiting for him to come asking for it. For example, the editor could display bottlenecks in red when the programmer edits the source code. Another approach would be to somehow represent what’s happening in running programs. This would be an especially big win in server-based applications, where you have lots of running programs to look at. An active profiler could show graphically what’s happening in memory as a program’s running, or even make sounds that tell what’s happening.</p>
<p>或许可以做 “主动性能分析器”—— 主动把性能数据推给程序员，而非等他们来查。比如，编辑器在程序员编辑源码时，用红色标记瓶颈。另一种方式是可视化运行中程序的状态 —— 这对服务器应用尤其有用，因为有很多运行中的程序可观察。主动性能分析器可以图形化显示程序运行时的内存状态，甚至用声音提示。</p>
<p>Sound is a good cue to problems. In one place I worked, we had a big board of dials showing what was happening to our web servers. The hands were moved by little servomotors that made a slight noise when they turned. I couldn’t see the board from my desk, but I found that I could tell immediately, by the sound, when there was a problem with a server.</p>
<p>声音是个好的问题信号。我以前工作的地方，有块大仪表盘显示 web 服务器的状态，指针由小伺服电机驱动，转动时会发出轻微声响。我在座位上看不见仪表盘，但能通过声音立刻判断服务器是否出问题。</p>
<p>It might even be possible to write a profiler that would automatically detect inefficient algorithms. I would not be surprised if certain patterns of memory access turned out to be sure signs of bad algorithms. If there were a little guy running around inside the computer executing our programs, he would probably have as long and plaintive a tale to tell about his job as a federal government employee. I often have a feeling that I’m sending the processor on a lot of wild goose chases, but I’ve never had a good way to look at what it’s doing.</p>
<p>甚至可能写出自动检测低效算法的性能分析器。某些内存访问模式可能就是坏算法的明确信号 —— 这不足为奇。如果电脑里有个小人在执行程序，他的工作吐槽可能和联邦公务员一样长。我总觉得自己让处理器做了很多无用功，却没法看清它在干嘛。</p>
<p>A number of Lisps now compile into byte code, which is then executed by an interpreter. This is usually done to make the implementation easier to port, but it could be a useful language feature. It might be a good idea to make the byte code an official part of the language, and to allow programmers to use inline byte code in bottlenecks. Then such optimizations would be portable too.</p>
<p>现在很多 Lisp 先编译成字节码，再用解释器执行 —— 这通常是为了便于移植，但也可以成为有用的语言特性。或许可以把字节码定为语言的官方部分，允许程序员在瓶颈处嵌入字节码 —— 这样优化也能移植。</p>
<p>The nature of speed, as perceived by the end-user, may be changing. With the rise of server-based applications, more and more programs may turn out to be i&#x2F;o-bound. It will be worth making i&#x2F;o fast. The language can help with straightforward measures like simple, fast, formatted output functions, and also with deep structural changes like caching and persistent objects.</p>
<p>用户感知的 “速度” 本质可能在变。随着服务器应用兴起，越来越多程序会受 I&#x2F;O 限制 —— 优化 I&#x2F;O 很重要。语言可以通过简单措施（如快速格式化输出函数）和深层结构（如缓存、持久化对象）提供支持。</p>
<p>Users are interested in response time. But another kind of efficiency will be increasingly important: the number of simultaneous users you can support per processor. Many of the interesting applications written in the near future will be server-based, and the number of users per server is the critical question for anyone hosting such applications. In the capital cost of a business offering a server-based application, this is the divisor.</p>
<p>用户关心响应时间，但另一种效率会越来越重要：每处理器支持的并发用户数。未来很多有趣的应用都是服务器端的，对托管者来说，“每服务器用户数” 是关键问题 —— 这是决定服务器应用业务资本成本的除数。</p>
<p>For years, efficiency hasn’t mattered much in most end-user applications. Developers have been able to assume that each user would have an increasingly powerful processor sitting on their desk. And by Parkinson’s Law, software has expanded to use the resources available. That will change with server-based applications. In that world, the hardware and software will be supplied together. For companies that offer server-based applications, it will make a very big difference to the bottom line how many users they can support per server.</p>
<p>多年来，多数终端用户应用不太在乎效率。开发者可以假设每个用户的桌面处理器会越来越强，而根据帕金森定律，软件会膨胀到占满资源。但服务器应用会改变这一点：在那个世界里，硬件和软件是捆绑的。对提供服务器应用的公司来说，每服务器支持的用户数直接影响底线。</p>
<p>In some applications, the processor will be the limiting factor, and execution speed will be the most important thing to optimize. But often memory will be the limit; the number of simultaneous users will be determined by the amount of memory you need for each user’s data. The language can help here too. Good support for threads will enable all the users to share a single heap. It may also help to have persistent objects and&#x2F;or language level support for lazy loading.</p>
<p>有些应用中，处理器是瓶颈，执行速度是优化重点；但更多时候内存是瓶颈 —— 并发用户数取决于每个用户数据所需的内存。语言也能在这里发挥作用：良好的线程支持能让所有用户共享一个堆；持久化对象和语言级延迟加载也可能有帮助。</p>
<h3 id="9-Time"><a href="#9-Time" class="headerlink" title="9 Time"></a><strong>9 Time</strong></h3><p><strong>9 时间</strong></p>
<p>The last ingredient a popular language needs is time. No one wants to write programs in a language that might go away, as so many programming languages do. So most hackers will tend to wait until a language has been around for a couple years before even considering using it.</p>
<p>流行语言的最后一个要素是<strong>时间</strong>。没人想在可能消失的语言上写程序 —— 太多编程语言都是如此。所以多数黑客会等一种语言出现几年后，才考虑使用。</p>
<p>Inventors of wonderful new things are often surprised to discover this, but you need time to get any message through to people. A friend of mine rarely does anything the first time someone asks him. He knows that people sometimes ask for things that they turn out not to want. To avoid wasting his time, he waits till the third or fourth time he’s asked to do something; by then, whoever’s asking him may be fairly annoyed, but at least they probably really do want whatever they’re asking for.</p>
<p>新事物的发明者常惊讶地发现：让人们接受一个信息需要时间。我有个朋友，别人第一次求他做事，他很少答应 —— 他知道人们有时会求自己并不真正想要的东西。为了不浪费时间，他会等别人求到第三、四次 —— 这时对方可能已经很生气，但至少他们很可能是真的想要。</p>
<p>Most people have learned to do a similar sort of filtering on new things they hear about. They don’t even start paying attention until they’ve heard about something ten times. They’re perfectly justified: the majority of hot new whatevers do turn out to be a waste of time, and eventually go away. By delaying learning VRML, I avoided having to learn it at all.</p>
<p>多数人对新事物也有类似的过滤机制：听到十次以上才会开始关注。这很合理：多数 “热门新事物” 最终都是浪费时间，会消失。我因为推迟学 VRML，最后根本没学。</p>
<p>So anyone who invents something new has to expect to keep repeating their message for years before people will start to get it. We wrote what was, as far as I know, the first web-server based application, and it took us years to get it through to people that it didn’t have to be downloaded. It wasn’t that they were stupid. They just had us tuned out.</p>
<p>所以，任何新事物的发明者都得做好准备：多年重复自己的理念，人们才会开始听。据我所知，我们写了第一个基于 web 服务器的应用，但花了好几年才让人们明白 “它不需要下载”。不是他们笨，只是没把我们当回事。</p>
<p>The good news is, simple repetition solves the problem. All you have to do is keep telling your story, and eventually people will start to hear. It’s not when people notice you’re there that they pay attention; it’s when they notice you’re still there.</p>
<p>好消息是，重复就能解决问题。你只需不断讲自己的故事，人们最终会听见。人们不是在 “注意到你存在” 时关注你，而是在 “注意到你还在” 时。</p>
<p>It’s just as well that it usually takes a while to gain momentum. Most technologies evolve a good deal even after they’re first launched — programming languages especially. Nothing could be better, for a new techology, than a few years of being used only by a small number of early adopters. Early adopters are sophisticated and demanding, and quickly flush out whatever flaws remain in your technology. When you only have a few users you can be in close contact with all of them. And early adopters are forgiving when you improve your system, even if this causes some breakage.</p>
<p>势头的积累需要时间，这其实是好事。多数技术（尤其是编程语言）在推出后还会大幅演化。对新技术来说，有几年时间只被少数早期用户使用，再好不过。早期用户成熟且挑剔，能快速发现技术的缺陷。用户少时，你能和所有用户保持密切联系；而且早期用户在你改进系统（哪怕造成一些不兼容）时，也更宽容。</p>
<p>There are two ways new technology gets introduced: the organic growth method, and the big bang method. The organic growth method is exemplified by the classic seat-of-the-pants underfunded garage startup. A couple guys, working in obscurity, develop some new technology. They launch it with no marketing and initially have only a few (fanatically devoted) users. They continue to improve the technology, and meanwhile their user base grows by word of mouth. Before they know it, they’re big.</p>
<p>新技术的推广有两种方式：“有机增长” 和 “大爆炸”。有机增长就像经典的、资金不足的车库创业：几个人默默开发新技术，零营销，最初只有几个（狂热的）用户，边改进技术边靠口碑增长，不知不觉就做大了。</p>
<p>The other approach, the big bang method, is exemplified by the VC-backed, heavily marketed startup. They rush to develop a product, launch it with great publicity, and immediately (they hope) have a large user base.</p>
<p>另一种 “大爆炸” 方式，就像风投支持、大肆营销的创业公司：赶工开发产品，高调发布，希望立刻获得大量用户。</p>
<p>Generally, the garage guys envy the big bang guys. The big bang guys are smooth and confident and respected by the VCs. They can afford the best of everything, and the PR campaign surrounding the launch has the side effect of making them celebrities. The organic growth guys, sitting in their garage, feel poor and unloved. And yet I think they are often mistaken to feel sorry for themselves. Organic growth seems to yield better technology and richer founders than the big bang method. If you look at the dominant technologies today, you’ll find that most of them grew organically.</p>
<p>通常，车库创业者会羡慕大爆炸创业者 —— 他们光鲜自信，受风投青睐，能买最好的东西，发布时的公关还能让他们成名人。车库里的人觉得自己又穷又没人爱，但我认为他们不该自怨自艾。有机增长往往比大爆炸方式产生更好的技术，也让创始人更富有。看看如今的主流技术，多数都是有机增长来的。</p>
<p>This pattern doesn’t only apply to companies. You see it in sponsored research too. Multics and Common Lisp were big-bang projects, and Unix and MacLisp were organic growth projects.</p>
<p>这不仅适用于公司，也适用于赞助研究：Multics 和 Common Lisp 是大爆炸项目，而 Unix 和 MacLisp 是有机增长项目。</p>
<h3 id="10-Redesign"><a href="#10-Redesign" class="headerlink" title="10 Redesign"></a><strong>10 Redesign</strong></h3><p><strong>10 重新设计</strong></p>
<p>“The best writing is rewriting,” wrote E. B. White. Every good writer knows this, and it’s true for software too. The most important part of design is redesign. Programming languages, especially, don’t get redesigned enough.</p>
<p>E. B. White 曾说：“最好的写作是重写。” 优秀的作家都懂这个道理，软件也一样。设计中最重要的部分是<strong>重新设计</strong>，而编程语言尤其缺乏足够的重设计。</p>
<p>To write good software you must simultaneously keep two opposing ideas in your head. You need the young hacker’s naive faith in his abilities, and at the same time the veteran’s skepticism. You have to be able to think how hard can it be? with one half of your brain while thinking it will never work with the other.</p>
<p>写好软件，脑子里必须同时装着两个对立的想法：年轻黑客对自身能力的天真信心，和老手的怀疑精神。你得用一半脑子想 “能有多难？”，另一半想 “这肯定不行”。</p>
<p>The trick is to realize that there’s no real contradiction here. You want to be optimistic and skeptical about two different things. You have to be optimistic about the possibility of solving the problem, but skeptical about the value of whatever solution you’ve got so far.</p>
<p>关键是要意识到这并不矛盾：你要对 “解决问题的可能性” 乐观，对 “当前解决方案的价值” 怀疑。</p>
<p>People who do good work often think that whatever they’re working on is no good. Others see what they’ve done and are full of wonder, but the creator is full of worry. This pattern is no coincidence: it is the worry that made the work good.</p>
<p>做出好作品的人，常觉得自己的东西不行。别人惊叹于他们的成果，创造者却满是担忧。这不是巧合：正是担忧让作品变好。</p>
<p>If you can keep hope and worry balanced, they will drive a project forward the same way your two legs drive a bicycle forward. In the first phase of the two-cycle innovation engine, you work furiously on some problem, inspired by your confidence that you’ll be able to solve it. In the second phase, you look at what you’ve done in the cold light of morning, and see all its flaws very clearly. But as long as your critical spirit doesn’t outweigh your hope, you’ll be able to look at your admittedly incomplete system, and think, how hard can it be to get the rest of the way?, thereby continuing the cycle.</p>
<p>若能平衡希望与担忧，它们会像双腿蹬自行车一样推动项目前进。在创新的两阶段循环中：第一阶段，你受 “能解决问题” 的信心驱动，疯狂工作；第二阶段，你在清晨的冷静中审视成果，清晰地看到所有缺陷。但只要批判精神没压过希望，你就会看着虽不完美但已存在的系统，想 “再往前推一步能有多难？”—— 循环便得以继续。</p>
<p>It’s tricky to keep the two forces balanced. In young hackers, optimism predominates. They produce something, are convinced it’s great, and never improve it. In old hackers, skepticism predominates, and they won’t even dare to take on ambitious projects.</p>
<p>平衡这两种力量很难。年轻黑客往往乐观过头：做出东西就觉得完美，不再改进。老黑客则怀疑过头，不敢接手极具野心的项目。</p>
<p>Anything you can do to keep the redesign cycle going is good. Prose can be rewritten over and over until you’re happy with it. But software, as a rule, doesn’t get redesigned enough. Prose has readers, but software has users. If a writer rewrites an essay, people who read the old version are unlikely to complain that their thoughts have been broken by some newly introduced incompatibility.</p>
<p>任何能维持 “重新设计循环” 的事都是好的。散文可以一遍遍重写直到满意，但软件通常重写不够。散文有读者，软件有用户 —— 作家重写文章，读旧版的人不会抱怨 “新改动毁了我的想法”。</p>
<p>Users are a double-edged sword. They can help you improve your language, but they can also deter you from improving it. So choose your users carefully, and be slow to grow their number. Having users is like optimization: the wise course is to delay it. Also, as a general rule, you can at any given time get away with changing more than you think. Introducing change is like pulling off a bandage: the pain is a memory almost as soon as you feel it.</p>
<p>用户是把双刃剑：他们能帮你改进语言，也能阻碍改进。所以要谨慎选择用户，缓慢扩大规模。拥有用户就像优化：明智的做法是推迟。而且一般来说，你能做出的改变往往比想象中多。引入改变就像撕绷带：痛感几乎转瞬即逝。</p>
<p>Everyone knows that it’s not a good idea to have a language designed by a committee. Committees yield bad design. But I think the worst danger of committees is that they interfere with redesign. It is so much work to introduce changes that no one wants to bother. Whatever a committee decides tends to stay that way, even if most of the members don’t like it.</p>
<p>众所周知，委员会设计不出好语言 —— 委员会只会产出糟糕设计。但我觉得委员会最大的危险是干扰重设计：引入改变太麻烦，没人愿意费心。委员会的决定往往一成不变，哪怕多数成员不喜欢。</p>
<p>Even a committee of two gets in the way of redesign. This happens particularly in the interfaces between pieces of software written by two different people. To change the interface both have to agree to change it at once. And so interfaces tend not to change at all, which is a problem because they tend to be one of the most ad hoc parts of any system.</p>
<p>哪怕两个人的 “委员会” 也会阻碍重设计 —— 尤其是在两人分别写的软件模块接口上。改接口需要双方同时同意，所以接口往往完全不变 —— 但接口往往是系统中最随意的部分，这就成了问题。</p>
<p>One solution here might be to design systems so that interfaces are horizontal instead of vertical — so that modules are always vertically stacked strata of abstraction. Then the interface will tend to be owned by one of them. The lower of two levels will either be a language in which the upper is written, in which case the lower level will own the interface, or it will be a slave, in which case the interface can be dictated by the upper level.</p>
<p>解决办法或许是设计 “水平接口” 而非 “垂直接口”—— 让模块始终是垂直堆叠的抽象层。这样接口就会属于其中一方：若下层是上层的实现语言，下层拥有接口；若下层是 “从属”，接口可由上层决定。</p>
<h3 id="11-Lisp"><a href="#11-Lisp" class="headerlink" title="11 Lisp"></a><strong>11 Lisp</strong></h3><p><strong>11 Lisp 的未来</strong></p>
<p>What all this implies is that there is hope for a new Lisp. There is hope for any language that gives hackers what they want, including Lisp. I think we may have made a mistake in thinking that hackers are turned off by Lisp’s strangeness. This comforting illusion may have prevented us from seeing the real problem with Lisp, or at least Common Lisp, which is that it sucks for doing what hackers want to do. A hacker’s language needs powerful libraries and something to hack. Common Lisp has neither. A hacker’s language is terse and hackable. Common Lisp is not.</p>
<p>以上一切都意味着：新 Lisp 有希望。任何能给黑客想要的东西的语言都有希望，包括 Lisp。我们可能错以为黑客讨厌 Lisp 的 “怪异”—— 这个安慰性的错觉让我们忽视了 Lisp（至少 Common Lisp）的真正问题：它不适合黑客想做的事。黑客需要的语言要有强大的库和可编写的对象，Common Lisp 两者都没有；黑客需要语言简洁、可操作，Common Lisp 也没有。</p>
<p>The good news is, it’s not Lisp that sucks, but Common Lisp. If we can develop a new Lisp that is a real hacker’s language, I think hackers will use it. They will use whatever language does the job. All we have to do is make sure this new Lisp does some important job better than other languages.</p>
<p>好消息是：烂的不是 Lisp，是 Common Lisp。如果我们能开发一种真正的 “黑客 Lisp”，我相信黑客会用它。他们会用任何能解决问题的语言 —— 我们只需确保这种新 Lisp 在某些重要任务上比其他语言做得更好。</p>
<p>History offers some encouragement. Over time, successive new programming languages have taken more and more features from Lisp. There is no longer much left to copy before the language you’ve made is Lisp. The latest hot language, Python, is a watered-down Lisp with infix syntax and no macros. A new Lisp would be a natural step in this progression.</p>
<p>历史给了些鼓励。随着时间推移，新编程语言从 Lisp 借鉴的特性越来越多 —— 再抄下去，几乎就成了 Lisp。最新的热门语言 Python，就是弱化版的 Lisp（带中缀语法，无宏）。新 Lisp 会是这个演进过程的自然一步。</p>
<p>I sometimes think that it would be a good marketing trick to call it an improved version of Python. That sounds hipper than Lisp. To many people, Lisp is a slow AI language with a lot of parentheses. Fritz Kunze’s official biography carefully avoids mentioning the L-word. But my guess is that we shouldn’t be afraid to call the new Lisp Lisp. Lisp still has a lot of latent respect among the very best hackers — the ones who took 6.001 and understood it, for example. And those are the users you need to win.</p>
<p>我有时觉得，把它叫做 “改进版 Python” 会是个好营销 —— 这听起来比 Lisp 时髦。对很多人来说，Lisp 是 “慢腾腾的 AI 语言，满是括号”。Fritz Kunze 的官方传记都小心翼翼避开 “Lisp” 这个词。但我猜，我们不必害怕称新语言为 Lisp。在顶尖黑客中，Lisp 仍有不少潜在的尊重 —— 比如那些学过 6.001 并真正理解它的人。而这些正是你需要争取的用户。</p>
<p>In “How to Become a Hacker,” Eric Raymond describes Lisp as something like Latin or Greek — a language you should learn as an intellectual exercise, even though you won’t actually use it:<br>Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot.<br>If I didn’t know Lisp, reading this would set me asking questions. A language that would make me a better programmer, if it means anything at all, means a language that would be better for programming. And that is in fact the implication of what Eric is saying.</p>
<p>Eric Raymond 在《如何成为黑客》中，把 Lisp 比作拉丁语或希腊语 —— 一种哪怕不用，也该学的智力训练：</p>
<p>“学习 Lisp 的深刻启迪，会让你余生都成为更好的程序员 —— 哪怕你其实不常直接用 Lisp。”</p>
<p>如果我不懂 Lisp，读了这话会好奇：一种 “能让我成为更好程序员” 的语言，若有意义，必然是 “更适合编程” 的语言 —— 这正是 Eric 的潜台词。</p>
<p>As long as that idea is still floating around, I think hackers will be receptive enough to a new Lisp, even if it is called Lisp. But this Lisp must be a hacker’s language, like the classic Lisps of the 1970s. It must be terse, simple, and hackable. And it must have powerful libraries for doing what hackers want to do now.</p>
<p>只要这个想法还在，我认为黑客会接受新 Lisp，哪怕它叫 Lisp。但这种 Lisp 必须是 “黑客的语言”，像 20 世纪 70 年代的经典 Lisp 那样：简洁、简单、可操作，且有强大的库，能做黑客现在想做的事。</p>
<p>In the matter of libraries I think there is room to beat languages like Perl and Python at their own game. A lot of the new applications that will need to be written in the coming years will be server-based applications. There’s no reason a new Lisp shouldn’t have string libraries as good as Perl, and if this new Lisp also had powerful libraries for server-based applications, it could be very popular. Real hackers won’t turn up their noses at a new tool that will let them solve hard problems with a few library calls. Remember, hackers are lazy.</p>
<p>在库方面，我觉得有机会在 Perl 和 Python 的强项上打败它们。未来几年需要写的很多新应用都是服务器端的。新 Lisp 完全可以有和 Perl 一样好的字符串库；如果它还有强大的服务器应用库，会非常流行。顶尖黑客不会拒绝 “用几个库调用解决难题” 的新工具 —— 别忘了，他们很懒。</p>
<p>It could be an even bigger win to have core language support for server-based applications. For example, explicit support for programs with multiple users, or data ownership at the level of type tags.</p>
<p>让核心语言支持服务器应用会是更大的优势。比如，显式支持多用户程序，或在类型标记层面支持数据所有权。</p>
<p>Server-based applications also give us the answer to the question of what this new Lisp will be used to hack. It would not hurt to make Lisp better as a scripting language for Unix. (It would be hard to make it worse.) But I think there are areas where existing languages would be easier to beat. I think it might be better to follow the model of Tcl, and supply the Lisp together with a complete system for supporting server-based applications. Lisp is a natural fit for server-based applications. Lexical closures provide a way to get the effect of subroutines when the ui is just a series of web pages. S-expressions map nicely onto html, and macros are good at generating it. There need to be better tools for writing server-based applications, and there needs to be a new Lisp, and the two would work very well together.</p>
<p>服务器应用也回答了 “新 Lisp 该用来编什么” 的问题。让 Lisp 成为更好的 Unix 脚本语言也不错（反正现在已经够烂了），但我觉得有些领域更容易超越现有语言。或许该学 Tcl 的模式：把 Lisp 和完整的服务器应用支持系统捆绑。Lisp 天生适合服务器应用：词法闭包能在 “UI 只是一系列网页” 时实现子程序效果；s 表达式与 HTML 映射良好，宏擅长生成 HTML。现在需要更好的服务器应用工具，也需要新 Lisp—— 两者结合会很完美。</p>
<h3 id="12-The-Dream-Language"><a href="#12-The-Dream-Language" class="headerlink" title="12 The Dream Language"></a><strong>12 The Dream Language</strong></h3><p><strong>12 理想的语言</strong></p>
<p>By way of summary, let’s try describing the hacker’s dream language. The dream language is beautiful, clean, and terse. It has an interactive toplevel that starts up fast. You can write programs to solve common problems with very little code. Nearly all the code in any program you write is code that’s specific to your application. Everything else has been done for you.</p>
<p>总结一下，黑客的理想语言该是什么样的？它优美、干净、简洁，有启动快速的交互式顶层环境。你能用很少的代码解决常见问题，程序中几乎所有代码都是应用特定的 —— 其他都已由库完成。</p>
<p>The syntax of the language is brief to a fault. You never have to type an unnecessary character, or even to use the shift key much.</p>
<p>它的语法简直到了极致：从不用敲多余字符，甚至很少用 Shift 键。</p>
<p>Using big abstractions you can write the first version of a program very quickly. Later, when you want to optimize, there’s a really good profiler that tells you where to focus your attention. You can make inner loops blindingly fast, even writing inline byte code if you need to.</p>
<p>你能用高层抽象快速写出程序初稿；优化时，有优秀的性能分析器告诉你该聚焦哪里。你能让内层循环快得惊人，甚至在需要时嵌入字节码。</p>
<p>There are lots of good examples to learn from, and the language is intuitive enough that you can learn how to use it from examples in a couple minutes. You don’t need to look in the manual much. The manual is thin, and has few warnings and qualifications.</p>
<p>有很多好例子可学，语言直观到你能从例子中几分钟学会用法。不用常查手册，手册很薄，几乎没有警告和限制。</p>
<p>The language has a small core, and powerful, highly orthogonal libraries that are as carefully designed as the core language. The libraries all work well together; everything in the language fits together like the parts in a fine camera. Nothing is deprecated, or retained for compatibility. The source code of all the libraries is readily available. It’s easy to talk to the operating system and to applications written in other languages.</p>
<p>它的核心小巧，库强大且高度正交，设计得和核心一样精心。所有库配合默契，语言的每个部分都像精密相机的零件一样契合。没有过时特性，也没有为兼容保留的冗余。所有库的源码都触手可及，能轻松与操作系统和其他语言写的应用交互。</p>
<p>The language is built in layers. The higher-level abstractions are built in a very transparent way out of lower-level abstractions, which you can get hold of if you want.</p>
<p>它分层构建：高层抽象由低层抽象透明组成，你想用时就能接触到低层。</p>
<p>Nothing is hidden from you that doesn’t absolutely have to be. The language offers abstractions only as a way of saving you work, rather than as a way of telling you what to do. In fact, the language encourages you to be an equal participant in its design. You can change everything about it, including even its syntax, and anything you write has, as much as possible, the same status as what comes predefined.</p>
<p>任何不必隐藏的东西都对你开放。语言提供抽象是为了帮你省功夫，而非命令你该做什么。事实上，它鼓励你参与设计 —— 你能改变它的一切，包括语法，而且你写的任何东西，都尽可能与预定义内容有同等地位。</p>
<p>Notes</p>
<p>[1] Macros very close to the modern idea were proposed by Timothy Hart in 1964, two years after Lisp 1.5 was released. What was missing, initially, were ways to avoid variable capture and multiple evaluation; Hart’s examples are subject to both.</p>
<p>[1] 与现代宏概念极为接近的想法，由蒂莫西・哈特（Timothy Hart）于 1964 年提出 —— 这是在 Lisp 1.5 发布两年后。最初的宏缺少避免 “变量捕获” 和 “多重求值” 的机制，而哈特的示例中这两个问题都存在。</p>
<p>[2] In When the Air Hits Your Brain, neurosurgeon Frank Vertosick recounts a conversation in which his chief resident, Gary, talks about the difference between surgeons and internists (“fleas”):</p>
<p>[2] 神经外科医生弗兰克・弗托西克（Frank Vertosick）在《当空气撞击你的大脑》（<em>When the Air Hits Your Brain</em>）一书中，记录了他与住院总医师加里（Gary）的一段对话，其中加里谈到了外科医生与内科医生（“跳蚤”）的区别：</p>
<p>Gary and I ordered a large pizza and found an open booth. The chief lit a cigarette. “Look at those goddamn fleas, jabbering about some disease they’ll see once in their lifetimes. That’s the trouble with fleas, they only like the bizarre stuff. They hate their bread and butter cases. That’s the difference between us and the fucking fleas. See, we love big juicy lumbar disc herniations, but they hate hypertension….”</p>
<p>加里和我点了个大披萨，找了个空 booth 坐下。这位主任点燃一支烟：“你看那些该死的跳蚤，没完没了地聊那些一辈子都遇不上一次的病。这就是跳蚤的问题 —— 他们只喜欢离奇的玩意儿，讨厌日常的常见病。这就是我们和那些该死的跳蚤的区别。你看，我们就爱那些又大又多汁的腰椎间盘突出，但他们讨厌高血压……”</p>
<p>It’s hard to think of a lumbar disc herniation as juicy (except literally). And yet I think I know what they mean. I’ve often had a juicy bug to track down. Someone who’s not a programmer would find it hard to imagine that there could be pleasure in a bug. Surely it’s better if everything just works. In one way, it is. And yet there is undeniably a grim satisfaction in hunting down certain sorts of bugs.</p>
<p>很难把腰椎间盘突出想成 “多汁” 的（除非从字面意义）。但我大概懂他们的意思。我也常遇到 “多汁的 bug” 要去追查。不是程序员的人很难理解：调试 bug 怎么会有乐趣？显然，一切正常不是更好吗？某种意义上确实如此。但不可否认，追查某些 bug 时，会有种冷酷的满足感。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/" class="category-chain-item">文章翻译</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/PAUL-GRAHAM/" class="print-no-link">#PAUL GRAHAM</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>编程语言的流行之道</div>
      <div>https://hokkaidornis.github.io/2025/08/13/being-popular/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jordan Zou</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/08/14/the-other-road-ahead/" title="前路殊途">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">前路殊途</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/08/13/disconnecting-distraction/" title="隔绝干扰">
                        <span class="hidden-mobile">隔绝干扰</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"sGbnjJgvnzWDjQzMDVNcUPGF-gzGzoHsz","appKey":"iD8UWkcGdixFXroZ6woVTZyD","path":"window.location.pathname","placeholder":"say something","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hokkaidornis.github.io/" target="_blank" rel="nofollow noopener"><span>Hokkaidornis</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         次
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
